import { app, BrowserWindow, globalShortcut, Tray, Menu, ipcMain, screen } from 'electron';import * as path from 'path';import { StateManager, AppState } from './stateManager';import { Transcriber } from './transcriber';import { TextInjector } from './textInjector';import { StartupManager } from './startupManager';import { AIProcessor } from './aiProcessor';import { DictionaryManager } from './dictionaryManager';import { SnippetManager } from './snippetManager';import { StyleManager } from './styleManager';let mainWindow: BrowserWindow | null = null;let settingsWindow: BrowserWindow | null = null;let tray: Tray | null = null;let stateManager: StateManager;let transcriber: Transcriber;let textInjector: TextInjector;let startupManager: StartupManager;let aiProcessor: AIProcessor;let dictionaryManager: DictionaryManager;let snippetManager: SnippetManager;let styleManager: StyleManager;function createOverlayWindow(): BrowserWindow {    const display = screen.getPrimaryDisplay();    const { width, height } = display.workAreaSize;    const windowWidth = 280;    const windowHeight = 100;    const margin = 20;    const window = new BrowserWindow({        width: windowWidth,        height: windowHeight,        x: Math.floor((width - windowWidth) / 2),        y: 60,         frame: false,        transparent: true,        alwaysOnTop: true,        skipTaskbar: true,        resizable: false,        focusable: true,        show: false,        webPreferences: {            preload: path.join(__dirname, '../preload.js'),            contextIsolation: true,            nodeIntegration: false,            backgroundThrottling: false        }    });    window.loadFile(path.join(__dirname, '../renderer/index.html'));    window.setVisibleOnAllWorkspaces(true);    window.webContents.on('before-input-event', (event, input) => {        if (input.key === 'Escape' && input.type === 'keyDown') {            window.hide();            stateManager.cancelRecording();            stateManager.setState(AppState.IDLE);            window.webContents.send('state-change', AppState.IDLE);            event.preventDefault();        }    });    return window;}function createSettingsWindow(): BrowserWindow {    const window = new BrowserWindow({        width: 600,        height: 500,        frame: true,        resizable: true,        show: false,        webPreferences: {            preload: path.join(__dirname, '../preload.js'),            contextIsolation: true,            nodeIntegration: false        }    });    window.loadFile(path.join(__dirname, '../renderer/settings.html'));    window.setMenuBarVisibility(false);    window.on('close', (e) => {        e.preventDefault();        window.hide();    });    return window;}function createTray(): Tray {    const iconPath = path.join(__dirname, '../../resources/icon.png');    const newTray = new Tray(iconPath);    const contextMenu = Menu.buildFromTemplate([        {            label: 'Show Overlay',            click: () => mainWindow?.show()        },        {            label: 'Settings',            click: () => {                if (settingsWindow) {                    settingsWindow.show();                    settingsWindow.focus();                }            }        },        { type: 'separator' },        {            label: 'Start on Boot',            type: 'checkbox',            checked: startupManager.isEnabled(),            click: (menuItem) => {                if (menuItem.checked) {                    startupManager.enable();                } else {                    startupManager.disable();                }            }        },        { type: 'separator' },        {            label: 'Quit',            click: () => {                app.quit();            }        }    ]);    newTray.setToolTip('ChattyWrity - Ctrl+Space to record');    newTray.setContextMenu(contextMenu);    return newTray;}function registerHotkey(): void {    const success = globalShortcut.register('Control+Space', () => {        handleHotkeyPress();    });    if (!success) {    }}async function processTranscription(rawText: string): Promise<string> {    await styleManager.detectActiveApp();    const isCodeMode = styleManager.isCodeMode();    aiProcessor.setCodeMode(isCodeMode);    let processed = dictionaryManager.applyDictionary(rawText);    const snippetResult = snippetManager.applySnippets(processed);    processed = snippetResult.text;    processed = aiProcessor.process(processed);    processed = styleManager.applyStyle(processed);    return processed;}async function stopAndTranscribe(continueLoop: boolean = false) {    stateManager.setState(AppState.PROCESSING);    mainWindow?.webContents.send('state-change', AppState.PROCESSING);    try {        const audioPath = await stateManager.stopRecording();        const rawText = await transcriber.transcribe(audioPath);        if (rawText && rawText.trim()) {            const processedText = await processTranscription(rawText);            mainWindow?.webContents.send('transcription-result', processedText);            await textInjector.type(processedText + (continueLoop ? ' ' : ''));        }        if (continueLoop) {            stateManager.setState(AppState.STARTING);            mainWindow?.webContents.send('state-change', AppState.STARTING);            await stateManager.startRecording();            stateManager.setState(AppState.RECORDING);            mainWindow?.webContents.send('state-change', AppState.RECORDING);        } else {            stateManager.setState(AppState.IDLE);            mainWindow?.webContents.send('state-change', AppState.IDLE);            updateEscShortcut(false);             setTimeout(() => {                if (stateManager.getState() === AppState.IDLE) {                    mainWindow?.hide();                }            }, 2000);        }    } catch (error: any) {        if (stateManager.getState() === AppState.IDLE) {            return;        }        if (error.message === 'Audio too short') {            if (continueLoop) {                stateManager.setState(AppState.STARTING);                await stateManager.startRecording();                stateManager.setState(AppState.RECORDING);                mainWindow?.webContents.send('state-change', AppState.RECORDING);                return;            } else {                stateManager.setState(AppState.IDLE);                mainWindow?.webContents.send('state-change', AppState.IDLE);                mainWindow?.hide();                return;            }        }        stateManager.setState(AppState.IDLE);        mainWindow?.webContents.send('state-change', AppState.IDLE);        mainWindow?.webContents.send('error', 'Transcription failed');    }}function updateEscShortcut(active: boolean) {    if (active) {        if (!globalShortcut.isRegistered('Escape')) {            globalShortcut.register('Escape', () => {                mainWindow?.hide();                stateManager.cancelRecording();                stateManager.setState(AppState.IDLE);                mainWindow?.webContents.send('state-change', AppState.IDLE);                updateEscShortcut(false);             });        }    } else {        if (globalShortcut.isRegistered('Escape')) {            globalShortcut.unregister('Escape');        }    }}async function handleHotkeyPress(): Promise<void> {    const currentState = stateManager.getState();    const isRecording = currentState === AppState.RECORDING || currentState === AppState.STARTING;    if (currentState === AppState.IDLE) {        stateManager.setState(AppState.STARTING);        mainWindow?.show();        mainWindow?.focus();        mainWindow?.webContents.send('state-change', AppState.STARTING);        updateEscShortcut(true);         try {            stateManager.onSilence = () => {                const current = stateManager.getState();                if (current === AppState.RECORDING) {                    stopAndTranscribe(true);                }            };            await stateManager.startRecording();            stateManager.setState(AppState.RECORDING);            mainWindow?.webContents.send('state-change', AppState.RECORDING);        } catch (err) {            stateManager.setState(AppState.IDLE);            mainWindow?.webContents.send('state-change', AppState.IDLE);            mainWindow?.webContents.send('error', 'MIC ERROR');            updateEscShortcut(false);        }    } else if (isRecording) {        stateManager.cancelRecording();        stateManager.setState(AppState.IDLE);        mainWindow?.webContents.send('state-change', AppState.IDLE);        updateEscShortcut(false);        setTimeout(() => {            if (stateManager.getState() === AppState.IDLE) {                mainWindow?.hide();            }        }, 1000);    }}app.whenReady().then(async () => {    stateManager = new StateManager();    transcriber = new Transcriber();    textInjector = new TextInjector();    startupManager = new StartupManager('ChattyWrity');    aiProcessor = new AIProcessor();    dictionaryManager = new DictionaryManager();    snippetManager = new SnippetManager();    styleManager = new StyleManager();    transcriber.loadModel().catch(console.error);    mainWindow = createOverlayWindow();    settingsWindow = createSettingsWindow();    tray = createTray();    registerHotkey();    ipcMain.handle('get-state', () => stateManager.getState());    ipcMain.handle('toggle-recording', () => handleHotkeyPress());    ipcMain.handle('hide-overlay', () => {        mainWindow?.hide();        stateManager.cancelRecording();        stateManager.setState(AppState.IDLE);        mainWindow?.webContents.send('state-change', AppState.IDLE);    });    ipcMain.handle('dictionary-get', () => dictionaryManager.export());    ipcMain.handle('dictionary-add-word', (_e, word: string) => dictionaryManager.addWord(word));    ipcMain.handle('dictionary-remove-word', (_e, word: string) => dictionaryManager.removeWord(word));    ipcMain.handle('dictionary-add-correction', (_e, wrong: string, correct: string) =>        dictionaryManager.addCorrection(wrong, correct));    ipcMain.handle('snippets-get', () => snippetManager.getAllSnippets());    ipcMain.handle('snippets-add', (_e, trigger: string, expansion: string, desc?: string) =>        snippetManager.addSnippet(trigger, expansion, desc));    ipcMain.handle('snippets-update', (_e, id: string, updates: any) =>        snippetManager.updateSnippet(id, updates));    ipcMain.handle('snippets-remove', (_e, id: string) => snippetManager.removeSnippet(id));    ipcMain.handle('styles-get', () => styleManager.getAllStyles());    ipcMain.handle('styles-set', (_e, appName: string, style: any) =>        styleManager.setAppStyle(appName, style));    ipcMain.handle('styles-remove', (_e, appName: string) => styleManager.removeAppStyle(appName));});app.on('will-quit', () => {    globalShortcut.unregisterAll();});app.on('window-all-closed', () => {});app.on('before-quit', () => {    settingsWindow?.destroy();});