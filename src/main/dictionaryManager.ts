import * as fs from 'fs';import * as path from 'path';import { app } from 'electron';interface Dictionary {    customWords: string[];    corrections: Record<string, string>;    autoLearned: string[];}export class DictionaryManager {    private dictionary: Dictionary;    private dataPath: string;    constructor() {        this.dataPath = path.join(app.getPath('userData'), 'dictionary.json');        this.dictionary = this.load();    }    private load(): Dictionary {        try {            if (fs.existsSync(this.dataPath)) {                const data = fs.readFileSync(this.dataPath, 'utf-8');                return JSON.parse(data);            }        } catch (error) {        }        return {            customWords: [                'ChatGPT', 'OpenAI', 'GitHub', 'TypeScript', 'JavaScript',                'Supabase', 'Vercel', 'Cloudflare', 'NextJS', 'ReactJS',                'API', 'URL', 'JSON', 'HTML', 'CSS', 'npm', 'Node'            ],            corrections: {},            autoLearned: []        };    }    private save(): void {        try {            const dir = path.dirname(this.dataPath);            if (!fs.existsSync(dir)) {                fs.mkdirSync(dir, { recursive: true });            }            fs.writeFileSync(this.dataPath, JSON.stringify(this.dictionary, null, 2));        } catch (error) {        }    }    addWord(word: string): void {        if (!this.dictionary.customWords.includes(word)) {            this.dictionary.customWords.push(word);            this.save();        }    }    removeWord(word: string): void {        this.dictionary.customWords = this.dictionary.customWords.filter(w => w !== word);        this.dictionary.autoLearned = this.dictionary.autoLearned.filter(w => w !== word);        this.save();    }    addCorrection(wrong: string, correct: string): void {        this.dictionary.corrections[wrong.toLowerCase()] = correct;        if (!this.dictionary.customWords.includes(correct) &&            !this.dictionary.autoLearned.includes(correct)) {            this.dictionary.autoLearned.push(correct);        }        this.save();    }    learnWord(word: string): void {        if (!this.dictionary.autoLearned.includes(word) &&            !this.dictionary.customWords.includes(word)) {            this.dictionary.autoLearned.push(word);            this.save();        }    }    getAllWords(): string[] {        return [...this.dictionary.customWords, ...this.dictionary.autoLearned];    }    getCustomWords(): string[] {        return [...this.dictionary.customWords];    }    getCorrections(): Record<string, string> {        return { ...this.dictionary.corrections };    }    applyDictionary(text: string): string {        let result = text;        for (const [wrong, correct] of Object.entries(this.dictionary.corrections)) {            const regex = new RegExp(`\\b${this.escapeRegex(wrong)}\\b`, 'gi');            result = result.replace(regex, correct);        }        for (const word of this.getAllWords()) {            const regex = new RegExp(`\\b${this.escapeRegex(word)}\\b`, 'gi');            result = result.replace(regex, word);        }        return result;    }    private escapeRegex(str: string): string {        return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');    }    export(): Dictionary {        return { ...this.dictionary };    }    import(data: Partial<Dictionary>): void {        if (data.customWords) {            this.dictionary.customWords = data.customWords;        }        if (data.corrections) {            this.dictionary.corrections = data.corrections;        }        if (data.autoLearned) {            this.dictionary.autoLearned = data.autoLearned;        }        this.save();    }}