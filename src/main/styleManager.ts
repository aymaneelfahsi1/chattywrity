import * as fs from 'fs';import * as path from 'path';import { app } from 'electron';const activeWin = require('active-win');type StyleMode = 'formal' | 'casual' | 'neutral' | 'code';interface AppStyle {    mode: StyleMode;    casing?: 'auto' | 'upper' | 'lower' | 'title';    signOff?: boolean;    removeEmoji?: boolean;}interface StyleData {    appStyles: Record<string, AppStyle>;    defaultStyle: AppStyle;}export class StyleManager {    private styles: StyleData;    private dataPath: string;    private currentApp: string = '';    constructor() {        this.dataPath = path.join(app.getPath('userData'), 'styles.json');        this.styles = this.load();    }    private load(): StyleData {        try {            if (fs.existsSync(this.dataPath)) {                const data = fs.readFileSync(this.dataPath, 'utf-8');                return JSON.parse(data);            }        } catch (error) {        }        return {            appStyles: {                'Code.exe': { mode: 'code', casing: 'auto' },                'code.exe': { mode: 'code', casing: 'auto' },                'cursor.exe': { mode: 'code', casing: 'auto' },                'devenv.exe': { mode: 'code', casing: 'auto' },                'idea64.exe': { mode: 'code', casing: 'auto' },                'notepad++.exe': { mode: 'code', casing: 'auto' },                'OUTLOOK.EXE': { mode: 'formal', signOff: true },                'outlook.exe': { mode: 'formal', signOff: true },                'Mailbird.exe': { mode: 'formal', signOff: true },                'thunderbird.exe': { mode: 'formal', signOff: true },                'WhatsApp.exe': { mode: 'casual', removeEmoji: false },                'Telegram.exe': { mode: 'casual', removeEmoji: false },                'Discord.exe': { mode: 'casual', removeEmoji: false },                'Slack.exe': { mode: 'casual' },                'Teams.exe': { mode: 'neutral' },                'ms-teams.exe': { mode: 'neutral' },                'WINWORD.EXE': { mode: 'neutral' },                'EXCEL.EXE': { mode: 'neutral' },                'POWERPNT.EXE': { mode: 'neutral' },                'notion.exe': { mode: 'neutral' },                'Obsidian.exe': { mode: 'neutral' }            },            defaultStyle: { mode: 'neutral' }        };    }    private save(): void {        try {            const dir = path.dirname(this.dataPath);            if (!fs.existsSync(dir)) {                fs.mkdirSync(dir, { recursive: true });            }            fs.writeFileSync(this.dataPath, JSON.stringify(this.styles, null, 2));        } catch (error) {        }    }    async detectActiveApp(): Promise<string> {        try {            const window = await activeWin();            if (window?.owner?.name) {                this.currentApp = window.owner.name;                return this.currentApp;            }        } catch (error) {        }        return '';    }    getStyleForApp(appName?: string): AppStyle {        const app = appName || this.currentApp;        return this.styles.appStyles[app] || this.styles.defaultStyle;    }    isCodeMode(): boolean {        const style = this.getStyleForApp();        return style.mode === 'code';    }    setAppStyle(appName: string, style: AppStyle): void {        this.styles.appStyles[appName] = style;        this.save();    }    removeAppStyle(appName: string): void {        delete this.styles.appStyles[appName];        this.save();    }    getAllStyles(): Record<string, AppStyle> {        return { ...this.styles.appStyles };    }    applyStyle(text: string, appName?: string): string {        const style = this.getStyleForApp(appName);        let result = text;        switch (style.mode) {            case 'formal':                result = this.applyFormalStyle(result);                break;            case 'casual':                result = this.applyCasualStyle(result);                break;            case 'code':                break;            case 'neutral':            default:                break;        }        if (style.casing) {            result = this.applyCasing(result, style.casing);        }        return result;    }    private applyFormalStyle(text: string): string {        let result = text;        const contractions: Record<string, string> = {            "don't": "do not",            "won't": "will not",            "can't": "cannot",            "shouldn't": "should not",            "wouldn't": "would not",            "couldn't": "could not",            "isn't": "is not",            "aren't": "are not",            "wasn't": "was not",            "weren't": "were not",            "haven't": "have not",            "hasn't": "has not",            "hadn't": "had not",            "doesn't": "does not",            "didn't": "did not",            "i'm": "I am",            "you're": "you are",            "we're": "we are",            "they're": "they are",            "it's": "it is",            "that's": "that is",            "there's": "there is",            "i've": "I have",            "you've": "you have",            "we've": "we have",            "they've": "they have",            "i'll": "I will",            "you'll": "you will",            "we'll": "we will",            "they'll": "they will",            "i'd": "I would",            "you'd": "you would",            "we'd": "we would",            "they'd": "they would"        };        for (const [contraction, expanded] of Object.entries(contractions)) {            const regex = new RegExp(`\\b${contraction}\\b`, 'gi');            result = result.replace(regex, expanded);        }        return result;    }    private applyCasualStyle(text: string): string {        return text;    }    private applyCasing(text: string, casing: string): string {        switch (casing) {            case 'upper':                return text.toUpperCase();            case 'lower':                return text.toLowerCase();            case 'title':                return text.replace(/\b\w/g, c => c.toUpperCase());            case 'auto':            default:                return text;        }    }    getCurrentApp(): string {        return this.currentApp;    }}