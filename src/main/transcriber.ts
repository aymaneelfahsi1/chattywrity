import * as path from 'path';import * as fs from 'fs';import { app } from 'electron';import { spawn, ChildProcess } from 'child_process';export class Transcriber {    private modelPath: string;    private whisperPath: string = '';    private modelName = 'ggml-small.en-q8_0.bin';     constructor() {        const resourcesPath = app.isPackaged            ? path.join(process.resourcesPath, 'models')            : path.join(__dirname, '../../models');        this.modelPath = path.join(resourcesPath, this.modelName);        this.findWhisperExecutable();    }    private findWhisperExecutable(): void {        try {            let nodeModulesPath = path.join(__dirname, '../../node_modules/nodejs-whisper');            if (app.isPackaged) {                nodeModulesPath = nodeModulesPath.replace('app.asar', 'app.asar.unpacked');            }            const whisperDir = path.join(nodeModulesPath, 'cpp/whisper.cpp');            const possiblePaths = [                path.join(whisperDir, 'main.exe'),                path.join(whisperDir, 'build/bin/Release/main.exe'),                path.join(whisperDir, 'build/bin/main.exe'),                path.join(whisperDir, 'build/Release/main.exe'),                path.join(whisperDir, 'main'),            ];            for (const p of possiblePaths) {                if (fs.existsSync(p)) {                    this.whisperPath = p;                    return;                }            }        } catch (error) {        }    }    async loadModel(): Promise<void> {        if (fs.existsSync(this.modelPath)) {        } else {        }    }    async transcribe(audioPath: string): Promise<string> {        if (this.whisperPath && fs.existsSync(this.whisperPath)) {            return this.transcribeWithExecutable(audioPath);        }        throw new Error('Whisper executable not found');    }    private async transcribeWithExecutable(audioPath: string): Promise<string> {        return new Promise((resolve, reject) => {            const args = [                '-m', this.modelPath,                '-f', audioPath,                '-l', 'en',                '--no-timestamps',                '-otxt',                '-t', '6',                '-p', '1'            ];            const process = spawn(this.whisperPath, args);            let output = '';            let errorOutput = '';            process.stdout.on('data', (data) => {                output += data.toString();            });            process.stderr.on('data', (data) => {                errorOutput += data.toString();            });            process.on('close', (code) => {                if (code === 0) {                    let text = output.trim();                    const expectedTxtFile = audioPath + '.txt';                    if (fs.existsSync(expectedTxtFile)) {                        try {                            text = fs.readFileSync(expectedTxtFile, 'utf-8').trim();                            fs.unlinkSync(expectedTxtFile);                        } catch (e) {                        }                    }                    resolve(text);                } else {                    reject(new Error(`Whisper exited with code ${code}`));                }            });            process.on('error', (err) => {                reject(err);            });        });    }}